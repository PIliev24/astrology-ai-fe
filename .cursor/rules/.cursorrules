# Astrology Frontend - Cursor Rules

## Project Overview
This is a Next.js 16 application using the App Router, React 19, TypeScript, and Tailwind CSS. It's an AI-powered astrology assistant with birth chart analysis, featuring authentication, chart management, and WebSocket-based chat functionality.

## Tech Stack
- **Framework**: Next.js 16.0.10 (App Router)
- **React**: 19.2.1
- **TypeScript**: 5.x (strict mode enabled)
- **Styling**: Tailwind CSS 4, shadcn/ui (New York style)
- **Data Fetching**: SWR 2.3.6
- **Forms**: React Hook Form + Zod
- **Icons**: Lucide React
- **Theming**: next-themes
- **Notifications**: Sonner

## Code Style & Conventions

### TypeScript
- Use strict TypeScript with proper type definitions
- Define types in `types/` directory, organized by domain
- Use interfaces for object shapes, types for unions/intersections
- Export types from `types/index.ts` for easy imports
- Prefer explicit return types for functions when not obvious
- Use `as const` for immutable constant objects

### File Naming
- Components: PascalCase (e.g., `ChartCard.tsx`)
- Hooks: camelCase with `use` prefix (e.g., `useBirthChart.ts`)
- Services: kebab-case (e.g., `api-client.tsx`)
- Utilities: kebab-case (e.g., `client-storage.ts`)
- Types: kebab-case (e.g., `astrology.ts`)
- Constants: kebab-case (e.g., `endpoints.ts`)

### Component Structure
- Use functional components with TypeScript
- Add `"use client"` directive for client components
- Server components by default (no directive needed)
- Organize components by feature in `components/` directory
- UI primitives in `components/ui/`
- Feature-specific components in feature folders (e.g., `components/chart/`)

### Imports
- Use path aliases: `@/` for root directory
- Group imports: external → internal → relative
- Use absolute imports with `@/` prefix
- Import types with `type` keyword when appropriate

### Hooks Pattern
- Create custom hooks in `hooks/` directory, organized by feature
- Use SWR for data fetching hooks
- Export hooks from feature `index.ts` files
- Follow naming: `use[Feature][Action]` (e.g., `useBirthChart`, `useCreateBirthChart`)
- Return objects with descriptive property names

### API & Services
- Use `services/api-client.tsx` for all API calls
- Define endpoints in `constants/endpoints.ts`
- Use the `api` object methods: `get`, `post`, `put`, `patch`, `delete`
- Handle authentication automatically via `apiFetch`
- Services should be in `services/` directory, one file per domain
- Export services from `services/index.ts`

### State Management
- Use React hooks for local state (`useState`, `useReducer`)
- Use SWR for server state and caching
- Use `client-storage.ts` utilities for localStorage operations
- Avoid global state management libraries unless necessary

### Styling
- Use Tailwind CSS utility classes
- Use `cn()` utility from `lib/utils.ts` for conditional classes
- Follow shadcn/ui component patterns
- Use CSS variables for theming (defined in `globals.css`)
- Prefer composition over custom CSS
- Use semantic color tokens (e.g., `text-muted-foreground`)

### Forms
- Use React Hook Form with Zod validation
- Define schemas with Zod
- Use `@hookform/resolvers/zod` for validation
- Follow shadcn/ui form component patterns
- Handle form errors appropriately

### Authentication
- Use JWT tokens stored in localStorage
- Implement automatic token refresh via `apiFetch`
- Use `RouteGuard` component for protected routes
- Auth hooks in `hooks/auth/`
- Auth services in `services/auth.service.ts`

### Error Handling
- Use custom `ApiError` class from `types/common.ts`
- Handle errors at appropriate levels (component, hook, service)
- Display user-friendly error messages
- Log errors to console for debugging

### Constants
- Define constants in `constants/` directory
- Use `as const` for type safety
- Group related constants (e.g., `ENDPOINTS`, `ROUTES`, `HOOK_KEYS`)
- Export from `constants/index.ts`

## Directory Structure

```
/
├── actions/          # Server actions
├── app/              # Next.js App Router pages
│   ├── (auth)/      # Route group for authenticated routes
│   └── layout.tsx   # Root layout
├── components/       # React components
│   ├── ui/          # shadcn/ui primitives
│   ├── auth/        # Auth-related components
│   ├── chart/       # Chart-related components
│   ├── chat/        # Chat-related components
│   ├── dashboard/   # Dashboard components
│   └── layout/      # Layout components
├── constants/        # App constants
├── hooks/            # Custom React hooks
│   ├── auth/        # Auth hooks
│   ├── birth-chart/ # Chart hooks
│   └── chat/        # Chat hooks
├── lib/              # Utility functions
├── services/         # API service layer
├── types/            # TypeScript type definitions
└── public/           # Static assets
```

## Best Practices

### Component Development
1. Keep components focused and single-purpose
2. Extract reusable logic into custom hooks
3. Use TypeScript interfaces for props
4. Prefer composition over prop drilling
5. Use React.memo() sparingly, only when needed

### Data Fetching
1. Use SWR hooks for server data
2. Implement proper loading and error states
3. Use SWR's `mutate` for optimistic updates
4. Configure SWR options appropriately (revalidation, etc.)

### Performance
1. Use Next.js Image component for images
2. Implement proper code splitting
3. Use dynamic imports for heavy components
4. Optimize bundle size

### Accessibility
1. Use semantic HTML elements
2. Add proper ARIA labels where needed
3. Ensure keyboard navigation works
4. Test with screen readers

### Security
1. Never expose sensitive data in client code
2. Validate all user inputs
3. Use HTTPS in production
4. Implement proper authentication checks

## Common Patterns

### Creating a New Feature
1. Create types in `types/[feature].ts`
2. Create service in `services/[feature].service.ts`
3. Create hooks in `hooks/[feature]/`
4. Create components in `components/[feature]/`
5. Add endpoints to `constants/endpoints.ts`
6. Create pages in `app/[feature]/`

### API Call Pattern
```typescript
// In service
import { api } from "@/services/api-client";
import { ENDPOINTS } from "@/constants";

export async function getFeature(id: string) {
  return api.get<FeatureResponse>(ENDPOINTS.FEATURE.BY_ID(id));
}

// In hook
import useSWR from "swr";
import { getFeature } from "@/services";

export function useFeature(id: string | null) {
  const { data, error, isLoading } = useSWR(
    id ? ["feature", id] : null,
    ([, id]) => getFeature(id)
  );
  return { data, error, isLoading };
}
```

### Component Pattern
```typescript
"use client";

import { ComponentProps } from "@/types";

interface ComponentProps {
  // props
}

export function Component({ prop }: ComponentProps) {
  // implementation
}
```

## Things to Avoid
- Don't use `any` type (use `unknown` if needed)
- Don't mix server and client components incorrectly
- Don't hardcode API endpoints (use constants)
- Don't duplicate type definitions
- Don't use inline styles (use Tailwind classes)
- Don't forget error handling
- Don't skip TypeScript types

## Testing Considerations
- Write tests for utility functions
- Test custom hooks
- Test form validation
- Test API error handling

## Environment Variables
- Use `lib/env.ts` for environment variable access
- Never commit `.env` files
- Document required environment variables

## Git Conventions
- Use descriptive commit messages
- Keep commits focused and atomic
- Use conventional commit format when possible

